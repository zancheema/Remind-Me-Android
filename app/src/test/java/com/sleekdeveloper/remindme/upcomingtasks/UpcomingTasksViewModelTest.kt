package com.sleekdeveloper.remindme.upcomingtasks

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import com.sleekdeveloper.remindme.MainCoroutineRule
import com.sleekdeveloper.remindme.data.source.FakeTestRepository
import com.sleekdeveloper.remindme.data.source.domain.Task
import com.sleekdeveloper.remindme.getOrAwaitValue
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.runBlocking
import org.hamcrest.CoreMatchers
import org.hamcrest.MatcherAssert
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import java.time.LocalDate
import java.time.LocalTime

class UpcomingTasksViewModelTest {
    private lateinit var repository: FakeTestRepository

    @get:Rule
    var instantTaskExecutorRule = InstantTaskExecutorRule()

    @ExperimentalCoroutinesApi
    @get:Rule
    val mainCoroutineRule = MainCoroutineRule()

    @Before
    fun initRepository() = runBlocking {
        repository = FakeTestRepository()
    }

    @Test
    fun tasks_LoadUpcomingTasks() = runBlocking {
        val task1 = Task("task_1", LocalDate.of(1999, 2, 2), LocalTime.now())
        val task2 = Task("task_2", LocalDate.now(), LocalTime.now())
        val task3 = Task("task_3", LocalDate.of(5000, 2, 1), LocalTime.now())
        repository.addTasks(task1, task2, task3)
        val viewModel = UpcomingTasksViewModel(repository)

        val tasks = viewModel.tasks.getOrAwaitValue()

        MatcherAssert.assertThat(tasks, CoreMatchers.`is`(listOf(task3)))
    }

    @Test
    fun noTasks_GeneratesNoTaskEvent() {
        val viewModel = UpcomingTasksViewModel(repository)

        val tasks = viewModel.tasks.getOrAwaitValue()
        MatcherAssert.assertThat(tasks.isEmpty(), CoreMatchers.`is`(true))
        val event = viewModel.noTasksEvent.getOrAwaitValue()
        MatcherAssert.assertThat(event.getContentIfNotHandled(), CoreMatchers.`is`(true))
    }

    @Test
    fun errorLoadingTasks_GeneratesTasksLoadingErrorEvent() {
        repository.setError(true)
        val viewModel = UpcomingTasksViewModel(repository)

        /* also activates the observer to set event */
        val tasks = viewModel.tasks.getOrAwaitValue()
        MatcherAssert.assertThat(tasks.isEmpty(), CoreMatchers.`is`(true))
        val event = viewModel.tasksLoadingErrorEvent.getOrAwaitValue()
        MatcherAssert.assertThat(event.getContentIfNotHandled(), CoreMatchers.`is`(true))
    }

    @Test
    fun successLoadingTasks_SetsTasksLoadingErrorEventToFalse() {
        val viewModel = UpcomingTasksViewModel(repository)

        /* also activates the observer to set event */
        val tasks = viewModel.tasks.getOrAwaitValue()
        /* tasks loading error is not generated by empty tasks */
        MatcherAssert.assertThat(tasks.isEmpty(), CoreMatchers.`is`(true))
        val event = viewModel.tasksLoadingErrorEvent.getOrAwaitValue()
        MatcherAssert.assertThat(event.getContentIfNotHandled(), CoreMatchers.`is`(false))
    }
}